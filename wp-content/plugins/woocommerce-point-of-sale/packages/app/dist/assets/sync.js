import{as as g,aa as h,I as d,at as l,au as f,av as y,aw as m,ax as b,ay as _,az as w,aA as k,aB as S,b as C,d as r,e as x,f as R,aC as B}from"../index.js";const D=g("updates",{state:()=>({items:[]}),actions:{reset(){this.$reset()},addItems(i){this.items=h.uniqBy([...this.items,...i],a=>a.join())},push(i){d.updateDBOption("last_synced",i.last_synced),this.addItems(i.items)},pop(i){const[a,n]=this.items.reduce(([e,s],t)=>t[1]===i?[[...e,t],s]:[e,[...s,t]],[[],[]]);this.items=n;const o=a.filter(([,,e])=>e==="update"),u=a.filter(([,,e])=>e==="delete");return{update:o.map(([e])=>e),delete:u.map(([e])=>e)}},async update(){const i=l();if(!i.syncing){const a=this.pop("coupon"),n=this.pop("product"),o=this.pop("product_category"),u=this.pop("user"),e=[];n.update.length&&e.push(await f({origin:"update",include:n.update})),n.delete.length&&e.push(await y({origin:"update",include:n.delete})),a.update.length&&e.push(await m({origin:"update",include:a.update,blocking:!1})),a.delete.length&&e.push(await b({origin:"update",include:a.delete,blocking:!1})),u.update.length&&e.push(await _({origin:"update",include:u.update,blocking:!1})),u.delete.length&&e.push(await w({origin:"update",include:u.delete,blocking:!1})),o.update.length&&e.push(await k({origin:"update",include:o.update,blocking:!1})),o.delete.length&&e.push(await S({origin:"update",include:o.delete,blocking:!1})),i.enqueue(e)}}}}),E=C(async({router:i,store:a})=>{const n=l(a),o=D(a);setInterval(async()=>{if(n.syncing&&n.syncOrigin==="load")return;const s=await d.getDBOption("last_synced",0),t=["product","product_category"];r("pos","cache_customers")&&t.push("user"),r("wc","coupons_enabled",!1)&&r("pos","cache_coupons",!0)&&t.push("coupon"),x("check_updates",{last_synced:String(s),collections:t.join(","),register_id:String(R("id"))}).then(c=>{if(c.ok){const p=c.body;o.push(p)}})},r("pos","check_updates_interval",15)*1e3),o.$subscribe((s,t)=>{t.items.length&&o.update()}),n.$subscribe((s,t)=>{t.tasks.length&&!t.currentTask&&(n.background=!0,n.next().then(c=>{if(c!==!0)throw new Error(c.message)}).catch(B))});const u=s=>!!(!s.name||["login","error-register-in-use"].includes(s.name)),e=s=>s.name?!["login","error-register-in-use","error-unauthorized"].includes(s.name):!1;i.beforeEach((s,t)=>{u(t)&&e(s)&&n.sync()})});export{E as default};
